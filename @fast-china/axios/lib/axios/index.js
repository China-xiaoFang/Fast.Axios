"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const e=require("axios"),r=require("lodash-unified"),o=require("./useAxios.js"),s=require("../uni-adapter/index.js");require("./type.js");const t={cancelDuplicateRequest:!0,loading:!1,loadingText:"加载中...",cache:!1,getMethodCacheHandle:!0,simpleDataFormat:!0,showErrorMessage:!0,showCodeMessage:!0,autoDownloadFile:!0,restfulResult:!0},l={cancelDuplicate:"重复请求，自动取消！",offLine:"您断网了！",fileDownloadError:"文件下载失败或此文件不存在！",302:"接口重定向了！",400:"参数不正确！",401:"您没有权限操作（令牌、用户名、密码错误）！",403:"您的访问是被禁止的！",404:"请求的资源不存在！",405:"请求的格式不正确！",408:"请求超时！",409:"系统已存在相同数据！",410:"请求的资源被永久删除，且不会再得到的！",422:"当创建一个对象时，发生一个验证错误！",429:"请求过于频繁，请稍后再试！",500:"服务器内部错误！",501:"服务未实现！",502:"网关错误！",503:"服务不可用，服务器暂时过载或维护！",504:"服务暂时无法访问，请稍后再试！",505:"HTTP版本不受支持！",[e.AxiosError.ETIMEDOUT]:"请求超时！",[e.AxiosError.ECONNABORTED]:"连接中断，服务器暂时过载或维护！",[e.AxiosError.ERR_NETWORK]:"网关错误，服务不可用，服务器暂时过载或维护！"},n=new Map,i=e=>{if(n.has(e)){n.get(e)(e),n.delete(e)}},a=e=>{if("undefined"!=typeof uni);else{const r=new Blob([e.data],{type:"application/octet-stream;charset=UTF-8"}),o=e.headers["content-disposition"],s=new RegExp("filename=([^;]+\\.[^\\.;]+);*").exec(o)[1],t=document.createElement("a"),l=window.URL.createObjectURL(r),n=/^["](.*)["]$/g;t.style.display="none",t.href=l,t.download=decodeURI(s.replace(n,"$1")),document.body.appendChild(t),t.click(),document.body.removeChild(t),window.URL.revokeObjectURL(l)}},u={request:u=>{var c;const d=o.useAxios(),p={...t,...u};if(r.isNil(p.requestCipher)&&(p.requestCipher=d.requestCipher),p.cache&&"GET"===p.method.toUpperCase()&&p.restfulResult&&p.simpleDataFormat){if(p.params&&console.warn("[Fast.Axios] 如果使用 Http Cache，则不能存在任何 'params' 参数"),null==(c=d.cache)?void 0:c.get){const e=d.cache.get(p.url);if(e)return Promise.resolve(e)}}else p.cache=!1;const m=(e=>{let{data:o}=e;const{url:s,method:t,params:l}=e;return r.isString(o)&&(o=JSON.parse(o)),[s,t,JSON.stringify(l),JSON.stringify(o)].join("&")})(u),v=Date.now(),g=e.create({adapter:"undefined"!=typeof uni?s.createUniAppAxiosAdapter():void 0,baseURL:d.baseUrl,timeout:d.timeout,headers:{...d.headers},responseType:"json"});return g.interceptors.request.use((r=>{var o,s,t;return i(m),p.cancelDuplicateRequest&&((r,o)=>{o.cancelToken=o.cancelToken||new e.CancelToken((e=>{n.has(r)||n.set(r,e)}))})(m,r),null==(o=d.interceptors)||o.request(r),p.loading&&(null==(s=d.loading)||s.show(p.loadingText)),"json"===r.responseType&&(p.requestCipher?null==(t=d.crypto)||t.encrypt(r,v):p.getMethodCacheHandle&&"GET"===r.method.toUpperCase()&&(r.params=r.params||{},r.params._=v)),r}),(e=>(console.error("[Fast.Axios]",e),Promise.reject(e)))),g.interceptors.response.use((o=>{var s,t,n,u,c,v,g;if(i(m),p.loading&&(null==(s=d.loading)||s.close(p)),null==(t=d.interceptors)?void 0:t.response)try{const e=d.interceptors.response(o,p);if(!r.isNil(e))return Promise.resolve(e)}catch(f){return console.error("[Fast.Axios]",f),Promise.reject(f)}if("blob"===o.config.responseType||"DOWNLOAD"===p.method.toUpperCase())return 200===o.status?(p.autoDownloadFile&&a(o),Promise.resolve(o)):(null==(n=d.message)||n.error(l.fileDownloadError),Promise.reject(o));if("json"===o.config.responseType){let s=o.data;if(p.restfulResult){const t=s,l=(null==t?void 0:t.code)??o.status;if(l<200||l>299||!1===(null==t?void 0:t.success))return p.showCodeMessage&&(null==t?void 0:t.message)&&(r.isObject(null==t?void 0:t.message)?null==(u=d.message)||u.error(JSON.stringify(null==t?void 0:t.message)):null==(c=d.message)||c.error(null==t?void 0:t.message)),console.error("[Fast.Axios]",new e.AxiosError((null==t?void 0:t.message)??"服务器内部错误！")),Promise.reject(new e.AxiosError((null==t?void 0:t.message)??"服务器内部错误！"))}return p.requestCipher&&(s=null==(v=d.crypto)?void 0:v.decrypt(o,p)),p.cache&&p.restfulResult&&p.simpleDataFormat&&(null==(g=d.cache)||g.set(p.url,null==s?void 0:s.data)),p.simpleDataFormat?Promise.resolve(null==s?void 0:s.data):Promise.resolve(s)}return p.simpleDataFormat?Promise.resolve(o.data):Promise.resolve(o)}),(async o=>{var s,t,n,a;if(i(m),p.loading&&(null==(s=d.loading)||s.close(p)),e.isCancel(o))return console.warn(`[Fast.Axios] ${l.cancelDuplicate}`),Promise.reject();if(!globalThis.navigator.onLine)return null==(t=d.message)||t.error(l.offLine),Promise.reject();if(null==(n=d.interceptors)?void 0:n.responseError)try{const e=d.interceptors.responseError(o,p);if(!r.isNil(e))return Promise.resolve(e)}catch(u){return console.error("[Fast.Axios]",u),Promise.reject(u)}if(p.showErrorMessage){const e=await(async e=>{var r,o,s,t,n,i,a,u,c,d,p;let m="";const v=(null==(o=null==(r=null==e?void 0:e.response)?void 0:r.data)?void 0:o.code)||(null==(s=null==e?void 0:e.response)?void 0:s.status)||(null==e?void 0:e.code)||"default";if("blob"===(null==(t=null==e?void 0:e.request)?void 0:t.responseType))try{m=null==(a=JSON.parse(await(null==(i=null==(n=null==e?void 0:e.response)?void 0:n.data)?void 0:i.text())))?void 0:a.message}catch(g){m=(null==(c=null==(u=null==e?void 0:e.response)?void 0:u.data)?void 0:c.message)||l[v]}else m=(null==(p=null==(d=null==e?void 0:e.response)?void 0:d.data)?void 0:p.message)||l[v];return m})(o);null==(a=d.message)||a.error(e)}return console.error("[Fast.Axios]",o),Promise.reject(o)})),g(p)},downloadFile:a};exports.useAxios=o.useAxios,exports.axiosUtil=u;
//# sourceMappingURL=index.js.map
